\appendix

\section{Undo in multiuser collaborative applications}
\label{sect:undo}

The availability of undo in a multiuser collaborative application is valuable because features available in single-user applications should also be available in corresponding multi-user applications. However, supporting undo in a multiuser collaborative application is much more difficult than supporting undo in single-user interactive applications because of the interleaving of operations performed by multiple users in a collaborative computing environment.


\subsection{An Example}

To illustrate the difficulties, let us consider a collaborative editing session with two users and a shared text document containing the string '"abc'". Suppose user 1 issues the operation $O_{1} = Ins[2,X]$ to insert the character '"X'" at position 2 after the character '"a'". The resulting document state is '"aXbc'". After this, user 2 issues operation $O_{2} = Ins[2,Y]$ to insert character '"Y'" after the character '"a'" to get the resulting document state '"aYXbc'". Suppose user 1 wants to undo his last operation, i.e. $O_{1}$. Her intended effect is to remove the '"X'" thus resulting in a document state '"aYbc'". First, blindly picking the \emph{globally} last operation, i.e. $O_{2}$ will undo the wrong operation. Second, simply executing the inverse operation $\overline{O_{1}} = Del[2,X]$ to delete the '"X'" at position 2 in the current document state '"aYXbc'" will delete '"Y'" instead of '"X'".

This means that any group undo solution must meet the challenge of undoing operations in a nonlinear way and must be able to achieve the correct undo effect in a document state that has been changed by other users'' operations. It can be clearly seen that undo in a groupware system is highly related to operational transformations.


\subsection{Types of Undo}

Generally a user expects an undo to reverse their own last operation (\emph{local} undo) rather than the globally last operation (\emph{global} undo). So an undo framework for groupware systems needs to allow selection of an operation to undo based on who performed it. Undoing the globally last action can be problematic as just before one user presses undo, another user may issue an operation. The effect of the operation may get executed at the first users site just before he effectively invokes the undo action. This would not result in the undoing of an operation which the first user intended to undo.

Further an undo mechanism may be classified by whether it allows to undo an arbitrary operation (called \emph{selective} undo) or it is restricted to the \emph{chronological} order.

It is still an open question how to select operations to be undone in a selective undo system. To undo the chronoligically last operation of the local user, the single familiar undo menu or shortcut is sufficient as it is always clear wich operation has to be undone.


\subsection{Existing Undo Solutions}

\subsubsection{DistEdit System}
The DistEdit system \cite{prakash94} allows operations to be undone in any order. However, it may be that an operation is not undoable because it conflicts with a later executed operations. The conflicts occur if a later operation happens at the same index as the operation to undo. They managed to solve some conflicting situations, but still a few remained in the finished system.

\subsubsection{adOPTed undo}
In the \emph{adOPTed} algorithm (see \ref{algo:adopted}) undo is supported by operational transformation. It allows to undo the chronological last operation of a user (it is implemented only for the local user but would it would be possible to extend it to an arbitrary user). To undo an operation, an inverse of this operation is generated by a special \emph{mirror} operator. This inverse operation must be placed at a valid location in the corresponding dimension of the interaction graph. No conflict can occur in undoing any operation. Another special operator called \emph{folding} is used for a correct working system. See \cite{ressel99} for a detailed description of this undo system.

\subsubsection{GOTO undo}
Sun \cite{sun02b} described an undo mechanism for the \emph{REDUCE} prototype. It is using the \emph{GOTO} algorithm (see \ref{algo:goto}) for \emph{do} and an algorithm called \emph{ANYUNDO} for \emph{undo}. The algorithm allows undoing arbitrary operations, so it is a selective undo system. The algorithm is described in great detail along many possible problems and how they were solved in this algorithm.



\section{Vector Time}
\label{sect:vectortime}

Most algorithms use \emph{vector time} to determine causal relations. Each site maintains a state vector $v$ that has $n$ components. $n$ is the number of participating sites. $S$ is the local site. The $i$-th component of $v$ denoted as $v[i]$ represents the number of operations executed from site $i$ at site $S$ (the local site). 

\begin{defn}
  For two time vectors u, v \\
  $u \leq v$ iff $\forall i : u[i] \leq v[i]$ \\
  $u < v$ iff $u \leq v$ and $u \not= v$ \\
  $u \parallel v$ iff $\neg(u < v)$ and $\neg(v < u)$
\end{defn}

Notice that $\leq$ and $<$ are partial orders. The \emph{concurrency relation} $\parallel$ is reflexive and symmetric.

The above definition gives us a very simple method to decide whether two events $e$ and $e'$ are causally related or not: We take their timestamps (vector times) and check whether $C(e) < C(e')$ or $C(e') < C(e)$ where $C(x)$ determines the timestamp of $x$. If the test succeeds, the events are causally related. Otherwise they are independent.

