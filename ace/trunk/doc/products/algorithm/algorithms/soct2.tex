\subsection{SOCT2}
\label{algo:soct2}

The SOCT2 concurrency control algorithm is proposed for a centralized and a distributed environment. For details, see \cite{suleiman97} \cite{suleiman98}.

\subsubsection{Centralized Environment}
In the centralized environment, a collaborative system is constituted of a set of user sites (one user per site) connected by a reliable network to a server site. The server site is responsible for the storage of the objects (i.e. documents, texts, graphics,...) shared by the users collaborating in a common activity. Each object may be manipulated by the users by means of specific operations that must be transmitted to the server to be executed. The progress of an operation is decomposed into four steps: generation, sending, reception and execution. After execution of an operation on the server, the results on the object are immeditaely visible to all users sharing that object.

When an operation $<op,i>$ generated from the object state $O_{i}$ is sent to the server, the server integrates the operation by transposing it forward with the sequence of concurrent operations in the history buffer (if any). The resulting operation is then executed and added to the history buffer.

At the server, causally ready operations, i.e. there are no concurrent operations available, are executed immediately. To serialize concurrent operations wit respect to the users intentions, the server uses a forward transposition function (equivalent to inclusive transformation). The forward transposition is specific to the application and to the semantic of the operations (e.g. insert and delete operations for text editing). This transposition makes use of the object history in order to determine if there are concurrent operations to which the operation to be executed must be forward transposed.

The object history is the sequence of all operations executed on the object and ordered in their execution order. To achieve the correct execution order of the operations, timestamps are used. Timestamps allow to determine if an operation precedes another one or is concurrent with it. A timestamp corresponds to the number of the object version, i.e. the number of executed operations on the object. A timestamp is associated to each object and to every generated operation. After each operation execution on an object, the timestamp of this object is incremented by one.  

\subsubsection{Distributed Environment}
The main difference to the centralized environment is that the shared objects are distributed and replicated. Thus the algorithm is more complex.

Each participating site is both a user and a server site. For each site, there exists a copy of the object O. Every operation intended to be executed on O must be executed on all the copies. For that, an operation generated by a site must be broadcast to all the other sites. The four events associated with an operation are: generation, broadcast, reception and execution.
Each site has to respect the following constraints:
\begin{itemize}
 \item immeditate execution of local operations after receiving them
 \item respect of the causality between the operations
 \item guarantee of the consistency of the copies by respecting intentions associated to the operations
\end{itemize}
To each copy of an object O on a site S is associated an operation history. So the problem is to construct, for every site S and for every object O, a history respecting the constraints above in such a way that if the object copies were identical at the beginning of the work session, they will also be identical each time the system is quiescent, that is to say when there are no more messages circulating in the network.

To respect the causality between operations a state vector is used for each site that counts operations generated by the other sites and executed on this site. When an operation is generated on a site S from an obect O, the current value of the state vector $V_{S,O}$ is associated with it. The message broadcast to sites is a triple: $<op,S_{op},V_{op},>$ where op is the generated operation, $S_{op}$ the generator site and $V_{op}$ the state vector associated with the operation. The state vectors associated with operations allow to compare operations to determine whether an operation precedes another one.

When a site S receives an operation op with its state vector $V_{op}$ coming from site $S_{op}$, this operation must not be executed by the application until all operations that precede it have been received and executed on S.

To guarantee the consistency of the copies, the forward transposition is used. To handle the problem that comes from the conflict between two insertion operations of a character at the same position, the insertion operation contains two additional parameters \emph{b} and \emph{a}. \emph{b}, (resp. \emph{a}) is a set of operations that have deleted a character before (resp. after) the inserted character. These parameters, which show how the operations were generated, help to determine the correct solution. Additionally, a priority (e.g. the character's code) to each character is used in the forward transposition function for two insertion operations.

An operation history H is maintained for each object O. The history H verifies:
\begin{itemize}
 \item all operations that precede Operation op are integrated in H
 \item op does not precede any operation of H
\end{itemize}
The causality is thus respected, and it remains to transpose op forward with its concurrent operations to obtain an operation whose execution respects the user intention and guarantees the data consistency. However in some cases (i.e. partially concurrent operations) the history must be re-ordered by means of backward transposition (changes the order of operations in the history while preserving equivalence) so that the forward transposition can be applied correctly (i.e. executed on two operations transformed in such a way as though they were defined on the same object state). Thus the history is reordered in such a way that the operations which precede op, the operation to be integrated, are regrouped before the operations wich are concurrent to op. By that, H will be separated into two sequences seq1 and seq2, so that all the operations of seq1 precede op and all the operations of seq2 are concurrent to op. The forward transposition for op can then be applied correctly to seq2 and finally be executed on the object.

\subsubsection{Properties}
\begin{itemize}
 \item proposed algorithm in centralized environment uses only forward transposition
 \item replicated environment uses forward and backward transposition (without undoing and redoing operations)
 \item uses timestamps (centralized env.) and state vectors (replicated env.) respectively to determine concurrent operations
 \item uses linear history buffer (called history) 
 \item the management of the sets \emph{a} and \emph{b} is difficult and transferring the insertion operation is not efficient
 \item no undo mechanism proposed
 \item was proved wrong by counterexamples by Imine et al. in \cite{imine04}
\end{itemize}
 