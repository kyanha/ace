\section{JGroups}
\emph{JGroups} is a toolkit for reliable multicast communication. It can be used to create groups of processes whose members can send messages to each other. The main features include:

\begin{itemize}
 \item Group creation and deletion (members can spread across LANs or WANs).
 \item Joining and leaving groups.
 \item Membership detection and notification about joined/left/crashed members
 \item Detection and removal of crashed members
 \item Sending and receiving of member-to-group messages (point-to-multipoint)
 \item Sending and receiving of member-to-member messages (point-to-point)
\end{itemize}

One of the most powerful features of \emph{JGroups} is its flexible protocol stack, which allows developers to adapt it to exactly match the application requirements and network characteristics. The benefit of this is that one has only to pay for what is actually used. By mixing and matching protocols, various differing application requirements can be satisfied. \emph{JGroups} comes with a number of protocols, for example

\begin{itemize}
 \item Transport protocols: UDP (IP multicast), TCP, JMS
 \item Fragmentation of large messages
 \item Reliable unicast and multicast message transmission. Lost messages are
       retransmitted.
 \item Failure detection: crashed members are excluded from membership
 \item Ordering protocols: atomic (all-or-none message delivery), FIFO, causal,
       total order (sequencer or token based)
 \item Membership
 \item Encryption
\end{itemize}

\emph{JGroups} allows developers to create reliable multicast applications where
\emph{reliability} is a deployment issue and does not have to be implemented by the application developer. This saves application developers significant amounts of time and allows for the application to be deployed in different environments without having to change code.

\subsection{Basics}
In order to join a group and send messages, a process has to create a channel. A channel is similar to a socket. When a client connects to a channel, it gives the name of the group it would like to join. A channel is always associated with a particular group (in it's connected state). The protocol stack takes care that channels within the same group find each other. Whenever a client connects to a channel with group name G, then it tries to find existing channels with the same name and joins them. If no members exist, a new group will be created.

When a channel is created, it is first in the unconnected state. The clients connects to the channel by calling \texttt{connect} supplying the group name that it wants to join. Once the channel is in the connected state, messages can be sent/received. A channel can be disconnected from a group by calling \texttt{disconnect} and it can be closed by calling \texttt{close}. A closed channel cannot be used anymore. Any attempt to do so results in an exception. The channel can only be connected to one group at the time. To communicate with multiple groups, multiple channels have to be created.

\subsubsection{Creating a channel}
To create a channel we can use the public constructor of \texttt{JChannel}. It looks as follows:

\begin{verbatim}
public JChannel(Object properties) throws ChannelException
\end{verbatim}

The properties arguments defines the composition of the protocol stack, that is the number and types of layers, their parameters and their order. For \texttt{JChannel} this has to be a string. For details about the composition of this string, please refer to the \emph{JGroups} users guide.

\subsubsection{Sending messages}
One of the two \texttt{send} methods of a channel are used to send messages to group members. The message payload can be any serializable object.

\begin{verbatim}
JChannel channel = ...;
channel.send(null, null, "test");
\end{verbatim}

The above code fragment sends the string "test" to all the other members in the group.

\subsubsection{Receiving messages}
The \texttt{receive} method is used to receive messages. A channel receives messages asynchronously from the network and stores them in a queue. When receive is called, the first message in the queue is removed and returned. If there is no message in the queue, the method invocation blocks.

There is a so-called \emph{building block} that provides a listener interface for receiving messages. The building block is called \texttt{PullPushAdapter}. This relieves the application developer from the task to create a separate reception thread. 

\subsection{Analysis}
\emph{JGroups} provides a very simple API to create groupware applications. A shared document in \ace could be represented as a separate group in \emph{JGroups}. 

\subsubsection{Shortcomings}
To join a group, one has to know the name of the group to join. There would have to be some mechanism to discover the available groups, or more specifically, the available groups that represent shared documents in \ace. A central server could be used to register group names or a well-known group could be used to advertise/query for available documents.

The current implementation of the group membership service is very simplistic. Joining a group is always successul. There is no way to forbid a particular member the access the group. This is a serious problem as the confidentiality of the document content cannot be guaranteed. A custom group membership service protocol implementation could probably solve this particular problem.

The \emph{JGroups} library is not programming language independent. It uses serialized objects as message payload. This can be seen as and advantage or as a disadvantage depending on the requirements of the application.
