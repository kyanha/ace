\chapter{Architectural Overview}


ACE is split into three independent layers. Each layer has a well-defined 
interface between the adjoining layers and well-defined responsibilities. 
A layer implementation can be replaced easily.

\begin{figure}[H]
 \centering
 \includegraphics[width=6.6cm,height=3.42cm]{../images/layers.eps}
 \caption{The Layers of ACE}
\end{figure}

\paragraph{Application Layer:} The application layer consists mainly in the 
graphical user interface. The layer implementation in ACE is built with
Java Swing.

\paragraph{Collaboration Layer:} The collaboration layer provides the
collaborative editing functionality to the application layer. It hosts the core
consistency control algorithm, which is based on the concept of operational 
transformation. By replacing the collaboration layer it would be theoretically 
possible to replace the employed consistency control algorithm. Further it uses 
the network layer for all network related functionality.

\paragraph{Network Layer:} The network layer is the lowest layer of ACE. It 
provides networking functionality to the collaboration layer. The two most 
important features are discovery of users and documents as well as communication 
with other users and sessions. Replacing the network layer allows to use a 
different network technology and/or a different protocol.



\section{Interface Application/Collaboration Layer}
The main class in the collaboration layer is the \texttt{CollaborationService}.
It is the entry point for an application layer. The main functionality 
exposed by the collaboration service are:
\begin{itemize}
 \item discovery of users and documents
 \item publishing of local documents
 \item registering invitation callback
\end{itemize}


\subsection{Collaboration Service}

\begin{figure}[H]
 \centering
 \includegraphics[width=13.83cm,height=7.27cm]{../images/finalreport/architecture_collaborationservice_uml.eps}
 \caption{CollaborationService Interface}
\end{figure}

The \texttt{CollaborationService} has to be initialized before it can
be used. This includes typically the following:

\begin{itemize}
 \item setting local user id
 \item setting local user details
 \item adding listeners
 \item setting callbacks
\end{itemize}

Each running instance of ACE needs a unique user id. This id is used to uniquely
identify users. The user id is set with the \texttt{setUserId} method. The
user details (at the moment just the nickname of the user) are set with
\texttt{setUserDetails}.

Further, the \texttt{CollaborationService} provides the possibility to set a
\texttt{ServiceFailureHandler} 
(see figure \ref{fig:archoverview.servicefailurehandler}). 
This failure handler is notified about 
service failures and is set with the \texttt{setFailureHandler} method. 
A typical service failure occurs if the port used by
ACE is already in use by another application. The failures passed to that
handler are really intended to be on the service level. Session level failures
are handled differently (see \ref{sect:archoverview.sessionfailure}). 

\begin{figure}[H]
 \centering
 \includegraphics[width=8.71cm,height=2.15cm]{../images/finalreport/architecture_servicefailurehandler_uml.eps}
 \caption{ServiceFailureHandler Interface}
 \label{fig:archoverview.servicefailurehandler}
\end{figure}


The registration of listeners as well as the setting of the invitation 
callback are discussed in the following.

Once all the necessary setup steps have been performed, the
\texttt{CollaborationService} can be started with a call to the
\texttt{start} method. At the end of the lifecycle of the
service, the \texttt{stop} method should be called.

The \texttt{getServerInfo} method can be used to get the local 
\texttt{ServerInfo} object, which specifies the IP and port of the
local server. Note that this information may not be available right
from the beginning, as it could be dynamically be determined when the
service is started. The application should therefore poll for that information
until it is available (e.g. with a timer).


\subsection{Discovery}
The collaboration service provides a listener registration mechanism for
users and documents. The corresponding methods are \texttt{addUserListener}
and \texttt{addDocumentListener}. These listeners are notified whenever a
new user or document is discovered by the underlying network layer. The two 
listener interfaces are pretty similar. 

\begin{figure}[H]
 \centering
 \includegraphics[width=8.47cm,height=4.97cm]{../images/finalreport/architecture_listener_uml.eps}
 \caption{DocumentListener and UserListener Interfaces}
\end{figure}

The passed in objects are instances of \texttt{RemoteUser} and
\texttt{RemoteDocument} respectively. The user objects have a \texttt{name}
property and documents have a \texttt{title} property. Further, they support
property change events that are used to notify registered 
\texttt{PropertyChangeListener} instances about property value changes. 
The collaboration layer guarantees that for each unique user and document
there is only one \texttt{RemoteUser} and \texttt{RemoteDocument}. This makes
it possible to register \texttt{PropertyChangeListener}s to be notified about
changes to the user name and document title. 

\begin{figure}[H]
 \centering
 \includegraphics[width=10.69cm,height=6.56cm]{../images/finalreport/architecture_userdocument_uml.eps}
 \caption{RemoteUser and RemoteDocument Interface}
\end{figure}


The
\texttt{RemoteDocument} objects have also a property that returns the
\texttt{RemoteUser} for the publisher of the document.


\subsection{Explicit User Discovery}
The described discovery mechanism relies on the services of the network layer.
It usually relies on IP multicast, which is most likely not available outside
of the local subnet. ACE provides therefore an explicit way to discover users.
The \texttt{CollaborationService} has a method \texttt{discoverUser} with
three parameters. A \texttt{DiscoveryCallback} is used to report the result
of the discovery, a \texttt{InetAddress} specifying the host, and a port.

\begin{figure}[H]
 \centering
 \includegraphics[width=8.47cm,height=2.19cm]{../images/finalreport/architecture_discoverycallback_uml.eps}
 \caption{DiscoveryCallback Interface}
\end{figure}

The callback is notified about the result of the discovery. The passed in
\texttt{DiscoveryResult} has a status and a status message. If the status
is equal to \texttt{DiscoveryResult.SUCCESS} the discovery succeeded. The
discovered user is returned through the normal code path, i.e. the
registered \texttt{UserListener} objects receive a notification.

\begin{figure}[H]
 \centering
 \includegraphics[width=5.57cm,height=2.54cm]{../images/finalreport/architecture_discoveryresult_uml.eps}
 \caption{DiscoveryResult}
\end{figure}


\subsection{Joining Documents}
\label{sect:archoverview.join}
\texttt{RemoteDocument} instances have a method \texttt{join}. This join
method can be used to join a remote document. All that is needed to
join a document is to register a \texttt{DocumentListener} with the 
\texttt{CollaborationListener} and call join on a discovered document.

The \texttt{join} method is designed to return immediately. Join is a 
potentially long running operation. First, the join request has to be sent
to the publisher. Second, it might take some time to transfer the document
content over the network. And last but not least, joining might need the 
approval of the publisher, which might take even longer. Thus, it is a sensible 
design decision to make this method non-blocking.

The result of join request is communicated to an object passed to the
\texttt{join} method implementing the \texttt{JoinCallback} interface.

\begin{figure}[H]
 \centering
 \includegraphics[width=9.07cm,height=2.58cm]{../images/finalreport/architecture_joincallback_uml.eps}
 \caption{JoinCallback Interface}
\end{figure}

Depending on the outcome of the join request, either \texttt{accepted} or
\texttt{rejected} is called. The \texttt{accepted} method takes an argument
of type \texttt{Session} and returns a \texttt{ParticipantSessionCallback}. 
The session
is the object that represents a collaborative editing session. It is
implemented by the collaboration layer and passed to the application layer.
The \texttt{ParticipantSessionCallback} in turn is returned by the application 
layer to the collaboration layer and is used by it to return received operations
and caret updates from other participants in the session.


\subsection{Publishing Documents}
To publish a document, the \texttt{CollaborationService} method \texttt{publish}
is used. The method has two parameters. The first is the session callback
for a published session (\texttt{PublishedSessionCallback}). The second method 
is the \texttt{DocumentModel}
of the document to be published. The \texttt{DocumentModel} contains the
document content, the title, as well as the current caret position of the
publisher. The collaboration service in turn returns an object of type
\texttt{PublishedSession}, which is used both to control the session as well
as sending operations and updates to the caret position.


\subsection{Inviting Users}
\label{sect:archoverview.invitingusers}
The \texttt{PublishedSession} has a method \texttt{invite} to invite users.
The invite method has as single parameter of type \texttt{RemoteUser}. 
The invite method is non-blocking, i.e. it
returns immediately. If the user accepts the invitation, he is added to the
list of participants of the session. The API does not provide a way to return
a feedback to the application layer whether the invitation is accepted.
Future versions may improve in that area and add a callback interface for
the invitation result.


\subsection{Receiving Invitations}
The \texttt{CollaborationService} has a method to register an
\texttt{InvitationCallback}. This callback is notified whenever another user
tries to invite the local user. 

\begin{figure}[H]
 \centering
 \includegraphics[width=7.48cm,height=2.15cm]{../images/finalreport/architecture_invitationcallback_uml.eps}
 \caption{InvitationCallback Interface}
\end{figure}

The passed in \texttt{Invitation} allows to retrieve the document for which
the user is invited as well as the publisher of the document. The
methods are \texttt{accept} and \texttt{reject}. They represent
the user actions of accepting or rejecting an invitation. 

\begin{figure}[H]
 \centering
 \includegraphics[width=6.60cm,height=3.76cm]{../images/finalreport/architecture_invitation_uml.eps}
 \caption{Invitation Interface}
\end{figure}

The \texttt{accept} method has as parameter a \texttt{JoinCallback}. This
callback is used exactly in the same way as the \texttt{JoinCallback} passed
to the \texttt{join} method of the \texttt{RemoteDocument} 
(see \ref{sect:archoverview.join}).


\subsection{Communicating with a Session}
Until now, we have not discussed how to communicate with a session. An
editing session is represented by the \texttt{Session} interface.
We have shown several ways to get a \texttt{Session} object:

\begin{itemize}
 \item joining a discovered remote document
 \item accepting an invitation
 \item publishing a local document (\texttt{PublishedSession})
\end{itemize}

All those ways have one thing in common: the application layer has to pass a 
\texttt{SessionCallback}
(in case of publish a \texttt{PublishedSessionCallback} and in every
other case a \texttt{ParticipantSessionCallback}) to the collaboration
layer. There are always these two objects, a \texttt{Session} and
a \texttt{SessionCallback}. The \texttt{Session} is used by the application
layer to send events to collaboration layer and a \texttt{SessionCallback}
is used to notify the application layer about session related events from the 
collaboration layer. Figure \ref{fig:archoverview.sessionandcallback} depicts 
this situation.

\begin{figure}[H]
 \centering
 \includegraphics[width=10.37cm,height=7.02cm]{../images/finalreport/architecture_session_sessioncallback.eps}
 \caption{Session and SessionCallback}
 \label{fig:archoverview.sessionandcallback}
\end{figure}

The figure \ref{fig:archoverview.session} shows the \texttt{Session} interface
hierarchy.

\begin{figure}[H]
 \centering
 \includegraphics[width=7.69cm,height=8.75cm]{../images/finalreport/architecture_session_uml.eps}
 \caption{Session and PublishedSession Interface}
 \label{fig:archoverview.session}
\end{figure}


\subsubsection{Locking}
In order that the system can guarantee the consistency of the replicas, we
must employ a locking scheme in the session and the document model of
the application layer implementation. While transforming messages, nobody
can be allowed to modify the document. 

Before determining the index and the text of a local operation, the session must
be locked. This ensures that from the point where the operation is determined
to the point where a request is created for the operation no other text is
inserted. Failing to do that would potentially result in an invalid index for
the local operation, as a processed remote operation could shift the text.

On the other hand for the same reasons, the session should also ensure with a 
lock that the local document model does not change while a remote request is 
processed.

The \texttt{SessionCallback} has a method \texttt{getLock}, from which
the collaboration layer gets a lock from the application layer. This
lock is used inside the session as well as it is available through the
\texttt{lock} and \texttt{unlock} methods. Make sure that for each call to
\texttt{lock} there is a matching \texttt{unlock} call. To be sure that unlock
is called, it must be placed inside a finally block.

\begin{figure}[H]
 \centering
 \small{\begin{verbatim}
 Session session = ...;
 session.lock();
 try {
   Operation op = ...;
   session.sendOperation(op);
 } finally {
   session.unlock();
 }
 \end{verbatim}}
 \caption{Proper locking of a Session}
\end{figure}

The documentation of the application layer (see \ref{chap:applicationlayer}) 
shows how the lock is implemented in our application layer implementation.


\subsubsection{Sending Operations}
The \texttt{sendOperation} and \texttt{sendCaretUpdate} methods are used to send 
locally generated operations or
caret updates to the other participants in the session. The \texttt{leave}
method allows to leave the session, i.e. stop participating. The participant
related methods allow to access the currently participating users. These
methods return objects implementing the \texttt{Participant} interface. This
interface has
two methods, one to get the \texttt{RemoteUser} and one to get the participant
id.

\begin{figure}[H]
 \centering
 \includegraphics[width=4.97cm,height=2.1cm]{../images/finalreport/architecture_participant_uml.eps}
 \caption{Participant Interface}
\end{figure}

A participant id is a session-wide unique identifier for a user. They are given
to a user when he joins a session by the publisher of the session. The local
participant id can be retrieved by the \texttt{getParticipantId} method.

The interface used by the collaboration layer to notify the client of the
session about events is the \texttt{SessionCallback} interface.


\subsubsection{PublishedSession}
The \texttt{PublishedSession} has some additional methods that correspond
to the additional actions available to the publisher of a document. The
publisher can change the name of the document through the
\texttt{setDocumentDetails} method. This happens most likely because the
publisher saves the document under a different name.
The \texttt{invite} method we have already seen in action in the section
\ref{sect:archoverview.invitingusers}.

Last but not least, the \texttt{kick} method can be used to kick a
participant from the session. This gives the publisher the possibility to
ban a user from the session.


\subsection{Session Callbacks}
\begin{figure}[H]
 \centering
 \includegraphics[width=14.89cm,height=8.47cm]{../images/finalreport/architecture_sessioncallback_uml.eps}
 \caption{SessionCallback Interfaces}
 \label{fig:archoverview.sessioncallback}
\end{figure}

The \texttt{SessionCallback} contains the methods common to both session types:
the participant and the publisher session. The 
\texttt{ParticipantSessionCallback} adds method that can only be called for
participants.


\subsubsection{Initialization and Termination of Participant Sessions}
When joining a document or accepting an invitation the session is passed to
the \texttt{JoinCallback} \texttt{accepted} method. This method has a
parameter of type \texttt{ParticipantSessionCallback}. The first two
methods called on that callback object are \texttt{setParticipantId}, which 
communicates the assigned participant id of the local participant, and 
\texttt{setDocument}, which sets the document. After these methods are called
all the other methods can be called by the session.

The \texttt{setDocument} method gets a \texttt{PortableDocument} instance
as parameter. It represents the document content at join time. A portable
document consists of a set of participants, their selections, as well as
a collection of fragments. A fragment is simply a continous run of text
belonging to one particular participant.

\begin{figure}[H]
 \centering
 \includegraphics[width=10.69cm,height=3.42cm]{../images/finalreport/architecture_portabledocument_uml.eps}
 \caption{PortableDocument Interfaces}
\end{figure}

The \texttt{kicked} method is called when the local participant
has been kicked from the session. A participant is typically kicked from
the session when he does not behave well. The \texttt{sessionTerminated}
method is called when the publisher conceals the published document. 

Additionally a session can fail. Session failures are common to publisher
sessions too and are described in the next section.


\subsubsection{Session Failures}
\label{sect:archoverview.sessionfailure}
The \texttt{sessionFailed}
method is used by the collaboration layer to notify the application layer
about a failed session. Reasons for this include failing network connection
to the publisher or unrecoverable situations in the collaboration or network
layer. The session should no longer be used after a call to 
this method.


\subsubsection{Reception}
The callback has methods to notify the client of the session about caret
updates and operations from other participants in the session. These methods
are named \texttt{receiveOperation} and \texttt{receiveCaretUpdate}
and accept both a \texttt{Participant} object
as well as either an \texttt{Operation} or a \texttt{CaretUpdate}.


\subsubsection{Participation Events}
The \texttt{participantJoined} and \texttt{participantLeft} methods are used to
notify the callback about
participants that joined or left the session. The initial set of participants
can be retrieved from the session when the document is set with
the \texttt{getParticipants} method.


\subsubsection{PublishedSessionCallback}
The \texttt{PublishedSessionCallback} method has a single additional method
\texttt{joinRequest} which has a parameter of type \texttt{JoinRequest}. It
is invoked whenever a user tries to join the session. The publisher of the
session can then decide if the user is allowed to join. The \texttt{JoinRequest}
has a single property of type \texttt{RemoteUser}, which is the user that 
tries to join. The request can either be accepted or rejected with the 
corresponding methods \texttt{accept} or \texttt{reject}.

\begin{figure}[H]
 \centering
 \includegraphics[width=4.97cm,height=3.03cm]{../images/finalreport/architecture_joinrequest_uml.eps}
 \caption{JoinRequest Interfaces}
\end{figure}



\section{Interface Collaboration/Network Layer}
In the last section we had a look at the interface between the application and
the collaboration layer. The collaboration layer itself cannot implement a
collaborative editor by itself. It needs a layer that provides the networking
functionality, the network layer. The network layer should not be used
directly by the application layer.

\subsection{Network Service}
The \texttt{NetworkService} interface is the entry point into the network layer.
Its functionality is in some aspects similar to the 
\texttt{CollaborationService}. 

\begin{figure}[H]
 \centering
 \includegraphics[width=13.83cm,height=5.57cm]{../images/finalreport/architecture_networkservice_uml.eps}
 \caption{NetworkService Interface}
 \label{fig:archoverview.networkservice}
\end{figure}

The \texttt{set\-User\-Id} and \texttt{set\-User\-Details} method are likely to
be passed directly from the \texttt{Collaboration\-Service} down to the
network service. In a similar way, the \texttt{get\-Server\-Info} method is
passed down directly through the collaboration layer.

The \texttt{start} must be called after all the callbacks have been set.
The \texttt{stop} method should be called to properly shutdown the service.


\subsection{TimestampFactory}
The collaboration layer has to set a \texttt{Timestamp\-Factory} on the
\texttt{NetworkService} with the \texttt{set\-Timestamp\-Factory} method. This
factory is used to convert a timestamp from a generic format (an array of
integers) into a \texttt{Timestamp} object which can be understood by the
collaboration layer. The \texttt{Timestamp} interface has a method which 
achieves the inverse operation, it is called \texttt{get\-Components} and
returns an integer array.

\begin{figure}[H]
 \centering
 \includegraphics[width=10.30cm,height=1.55cm]{../images/finalreport/architecture_timestampfactory_uml.eps}
 \caption{TimestampFactory and Timestamp Interface}
\end{figure}


\subsection{Network Service Callback}
The \texttt{NetworkService} interface has a method 
\texttt{setNetworkServiceCallback}. The network layer provides a tighter
one-to-one binding between itself and the upper layer through this
callback interface. Instead of exposing an additional set of listeners
(such as those provided by the collaboration layer: \texttt{UserListener}
and \texttt{DocumentListener}), it provides one unified callback interface.

\begin{figure}[H]
 \centering
 \includegraphics[width=10.44cm,height=5.15cm]{../images/finalreport/architecture_networkservicecallback_uml.eps}
 \caption{NetworkServiceCallback Interface}
\end{figure}


\subsubsection{Discovery}
The discovery results for documents are communicated through the 
\texttt{documentDiscovered},
\texttt{documentDiscarded}, and the
\texttt{documentDetailsChanged} methods. Similar methods exist for user
discovery (\texttt{userDiscovered}, \texttt{userDetailsChanged}, 
\texttt{userDiscarded}). These methods are similar to the 
\texttt{UserListener} and \texttt{DocumentListener} methods except that they
pass \texttt{RemoteUserProxy} as well as \texttt{RemoteDocumentProxy} 
objects. Additionally, there are the two methods \texttt{documentDetailsChanged}
and \texttt{userDetailsChanged}. These are called whenever the details of
a document or user changed. This is in contrast to the collaboration layer,
where these change events are passed as \texttt{PropertyChangeEvents} on 
the corresponding objects.

\begin{figure}[H]
 \centering
 \includegraphics[width=7.62cm,height=6.63cm]{../images/finalreport/architecture_userdocumentproxy_uml.eps}
 \caption{RemoteDocumentProxy and RemoteUserProxy Interfaces}
 \label{fig:archoverview.userdocumentproxy}
\end{figure}


\subsubsection{Receiving Invitations}
The network layer passes received invitations to the 
\texttt{Network\-Service\-Callback}'s \texttt{invitation\-Received} method.
This method has a parameter of type \texttt{Invitation\-Proxy}, which 
corresponds to the \texttt{Invitation} object in the collaboration layer.

\begin{figure}[H]
 \centering
 \includegraphics[width=7.62cm,height=2.40cm]{../images/finalreport/architecture_invitationproxy_uml.eps}
 \caption{InvitationProxy Interface}
\end{figure}

The invitation can be either be accepted or rejected with the methods
\texttt{accept} or \texttt{reject} respectively. The document for which
the invitation is meant is accessible throught the \texttt{get\-Document}
method.


\subsubsection{Service Failures}
Service failures are passed to the \texttt{NetworkServiceCallback} through
the \texttt{serviceFailure} method.


\subsection{Explicit User Discovery}
The method \texttt{discoverUser} is used to start an explicit discovery
of another user, for instance over the Internet. It corresponds to the
\texttt{discoverUser} method in the \texttt{CollaborationService}. The
only difference is, that it accepts a \texttt{DiscoveryNetworkCallback}
instance (instead of a \texttt{DiscoveryCallback} instance). The result
of the discovery is communicated through the methods 
\texttt{userDiscoveryFailed} and \texttt{userDiscoverySucceeded} method.
The actual discovered user (if the discovery is successful) is passed 
through the \texttt{NetworkServiceCallback}'s \texttt{userDiscovered} 
method.

\begin{figure}[H]
 \centering
 \includegraphics[width=8.26cm,height=2.86cm]{../images/finalreport/architecture_discoverynetworkcallback_uml.eps}
 \caption{DiscoveryNetworkCallback Interface}
\end{figure}


\subsection{Network Layer on the Participant's Side}
The participant side and the publisher side of the network layer differ
significantly.

\subsubsection{Joining Documents}
Documents are discovered through the \texttt{NetworkServiceCallback} methods
described above. A discovered document is represented by a 
\texttt{RemoteDocumentProxy} instance
(see figure \ref{fig:archoverview.userdocumentproxy}). 
This object provides similar methods
to the ones in the \texttt{RemoteDocument} interface. The \texttt{join}
method allows to join the given document. The only parameter to that method
is an implementation of the \texttt{JoinNetworkCallback} interface.

\begin{figure}[H]
 \centering
 \includegraphics[width=11.04cm,height=2.61cm]{../images/finalreport/architecture_joinnetworkcallback_uml.eps}
 \caption{JoinNetworkCallback Interface}
\end{figure}

This interface has two methods, \texttt{accepted} and \texttt{rejected}.
The \texttt{rejected} method notifies the callback that the join
was rejected. The passed in \texttt{code} argument specifies the reason, why
the join was rejected. The corresponding constants are defined in the
\texttt{JoinRequest} interface. A join can be rejected for several reasons.
To name a few: publisher rejects join, joining user is on a black list,
the joining user is already in the session, and some more.

On the other hand, the \texttt{accepted} method is invoked when the join
was accepted. The parameter of type \texttt{SessionConnection} represents
the connection to the session. Its purpose corresponds to the \texttt{Session}
interface in the collaboration layer. The callback has to return a
\texttt{SessionConnectionCallback} implementation (whose purpose corresponds
to the \texttt{SessionCallback} in the collaboration layer).


\subsubsection{SessionConnection}
The \texttt{SessionConnection} allows the collaboration layer to
communicate with the session. For each editing session there is
exactly one \texttt{SessionConnection} with its corresponding
\texttt{SessionConnectionCallback} instance.

\begin{figure}[H]
 \centering
 \includegraphics[width=10.09cm,height=4.30cm]{../images/finalreport/architecture_sessionconnection_uml.eps}
 \caption{SessionConnection Interface}
\end{figure}

The send methods allow the participant to send requests, caret updates,
and acknowledge messages to the session. In contrast to the session
layer the send methods deal with \texttt{Request}s (instead of
\texttt{Operation}s) and \texttt{CaretUpdateMessage}s (instead of
\texttt{CaretUpdate}s). The
\texttt{leave} method notifies the session that the local user does
no longer want to be part of the session. The \texttt{getParticipantId}
method gives access to the assigend participant id.


\subsubsection{SessionConnectionCallback}
The \texttt{SessionConnectionCallback} is used by the network layer
to pass session related events to the collaboration layer.

\begin{figure}[H]
 \centering
 \includegraphics[width=11.50cm,height=5.57cm]{../images/finalreport/architecture_sessionconnectioncallback_uml.eps}
 \caption{SessionConnectionCallback Interface}
\end{figure}

The \texttt{receive} methods pass a received message to the collaboration
layer. The \texttt{participantJoined} and \texttt{participantLeft} methods
notify the collaboration layer about changes in the set of participants.
At the beginning of the lifecycle of the session, both the participant
id and the document are passed to the callback. The document is of
type \texttt{ch.\-iserver.\-ace.\-net.\-PortableDocument}, which should not
be confused with the interface with the same name in the collaboration
layer.

\begin{figure}[H]
 \centering
 \includegraphics[width=7.55cm,height=3.40cm]{../images/finalreport/architecture_portabledocumentnet_uml.eps}
 \caption{PortableDocument Interface}
\end{figure}

The \texttt{sessionTerminated} message notifies the callback that the 
session has been closed
by the publisher of the document. The \texttt{kicked} method notifies the
participant that he has been kicked from the session.


\subsection{Network Layer on the Publisher's Side}
On the side of the publisher, the network service looks a bit different.
Let us start with explaining how a document can be published.

\subsubsection{Publishing Documents}
A document can be published through the \texttt{publish} method of the
\texttt{NetworkService}. This method takes two arguments, one is the
\texttt{DocumentServerLogic} and the other is a \texttt{DocumentDetails},
describing the document. The method returns a \texttt{DocumentServer}
object. These two objects are both defined as part of the interface between the
collaboration and the network layer.

\subsubsection{DocumentServer}
The \texttt{DocumentServer} interface 
represents a published document to the collaboration layer. The
\texttt{invite} method will be discussed later 
(see \ref{archoverview.net.invite}). The \texttt{setDocumentDetails}
method allows the change the document details (currently only the title).
This method corresponds to the \texttt{setDocumentDetails} method in
the \texttt{PublishedSession} interface of the collaboration layer.
Calling this method sends the changed document title to the other peers.

\begin{figure}[H]
 \centering
 \includegraphics[width=8.71cm,height=3.18cm]{../images/finalreport/architecture_documentserver_uml.eps}
 \caption{DocumentServer Interface}
\end{figure}

Finally, the \texttt{shutdown} method is called shutdown the document
server for the document. This should be called when a published document
is concealed.

\subsubsection{DocumentServerLogic}
\label{sect:archoverview.net.documentserverlogic}
The \texttt{DocumentServerLogic} represents the view of the network layer
on the collaboration layer for a published document. The only method
exposed by this interface is the \texttt{join} method, which has a single
parameter of type \texttt{ParticipantConnection}.

\begin{figure}[H]
 \centering
 \includegraphics[width=7.62cm,height=2.40cm]{../images/finalreport/architecture_documentserverlogic_uml.eps}
 \caption{DocumentServerLogic Interface}
\end{figure}

\subsubsection{ParticipantConnection}
The \texttt{ParticipantConnection} interface provides the collaboration layer
a way to send events to a particular participant. When the \texttt{join}
method on the \texttt{DocumentServerLogic} returns, the network layer does
not have any way to send events to the server from the participant. That
is because the join request is not yet accepted. The result of the join
request is directly communicated to the \texttt{ParticipantConnection}.
The \texttt{getUser} method allows the collaboration layer to extract the
user that wants to join the session.

\begin{figure}[H]
 \centering
 \includegraphics[width=12.59cm,height=6.84cm]{../images/finalreport/architecture_participantconnection_uml.eps}
 \caption{ParticipantConnection Interface}
\end{figure}

If the join is rejected, the \texttt{joinRejected} method is called passing
in a code (see the constants defined in the \texttt{JoinRequest} interface).
The connection is then no longer used by the collaboration layer and can thus
be destroyed.

If the join request is accepted, the following methods are called in order:
\begin{itemize}
 \item \texttt{setParticipantId} - sets the assigend participant id for that participant
 \item \texttt{joinAccepted} - passing in an instance of the \texttt{ParticipantPort} interface
 \item \texttt{sendDocument} - sends the initial document
\end{itemize} 

As long as the participant is part of the session, the following methods
are called:
\begin{itemize}
 \item \texttt{sendAcknowledge}
 \item \texttt{sendCaretUpdateMessage}
 \item \texttt{sendRequest}
 \item \texttt{sendParticipantJoined}
 \item \texttt{sendParticipantLeft}
\end{itemize}

These are the basic messages sent as part of a session from the server.

The connection is terminated by a call to \texttt{close}. If the participant
is kicked from the session, first \texttt{sendKicked} is called just before
the call to \texttt{close}.


\subsubsection{ParticipantPort}
The network layer gets a \texttt{ParticipantPort} implementation through
the \texttt{joinAccepted} method. Most important, it has methods to receive
requests, caret update messages, as well as acknowledges from the participant.

\begin{figure}[H]
 \centering
 \includegraphics[width=9.13cm,height=3.88cm]{../images/finalreport/architecture_participantport_uml.eps}
 \caption{ParticipantPort Interface}
\end{figure}

The \texttt{leave} method allows a participant to leave the session and
the \texttt{getParticipantId} provides a way to query the assigned
participant id.


\subsubsection{Invitations}
\label{archoverview.net.invite}
The \texttt{DocumentServer} has a method named \texttt{invite}. This method
is used by the publisher's collaboration layer to send an invitation for the
document represented by the \texttt{DocumentServer} instance. The single
argument of that method is of type \texttt{InvitationPort}.

\begin{figure}[H]
 \centering
 \includegraphics[width=8.00cm,height=3.18cm]{../images/finalreport/architecture_invitationport_uml.eps}
 \caption{InvitationPort Interface}
\end{figure}

The \texttt{InvitationPort} provides the network layer a way to accept or
reject an invitation. The invitation is sent to the invited user. The response
of that particular user is then reported back through the 
\texttt{InvitationPort} to the collaboration layer of the publisher. The
method \texttt{accept} behaves similarly to the \texttt{join} method of
the \texttt{DocumentServerLogic} interface. The port for the accepted 
connection is passed to the \texttt{joinAccepted} method of the passed
in connection.



\section{Fitting the Layers Together}
In the previous two sections we have discussed the API between two adjacent
layers separately. In this section we show how the whole fits together,
as discussing the layers separately is a bit abstract.
Because the design is based on 
interfaces it is hard to say how exactly the implementation works. However,
the figures represent conceptually how the layers fit together. We will
describe the messages being sent based on use cases.


\subsection{Explanations}
In figure \ref{fig:archoverview.flow.skeleton} the basic skeleton of the
figures used in the following sections is depicted. The figure shows the
three layers of ACE: application, collaboration, and network layer. In 
the following figures, these three layers are also visible. Class names
printed inside a layer (i.e. inside an area separated by dashed lines), it
belongs to that layer. Messages sent back and forth are shown with arrows. The
arrows have labels that correspond to the method beeing called on the target
object.

\begin{figure}[H]
 \centering
 \includegraphics[width=7.80cm,height=4.87cm]{../images/finalreport/architecture_flows/skeleton.eps}
 \caption{Skeleton of Message Flows}
 \label{fig:archoverview.flow.skeleton}
\end{figure}


\subsection{Publishing a Document}
The figure \ref{archoverview.flow.publish} shows how a document is published.
First, the \texttt{publish} method of the \texttt{CollaborationService} is 
called. The collabation layer in turn calls \texttt{publish} on the
\texttt{NetworkService}. However, the call is not simply passed through the
collaboration layer. The collaboration layer creates an object implementing
the \texttt{DocumentServerLogic}, which handles all the server logic of a
published document. This server logic hosts the server part of the
operational transformation algorithm. It receives requests from users, 
transforms them and forwards them to all other participants in the session.
The \texttt{DocumentServerLogic} represents the interface seen by the
network layer. For a description of that interface see 
\ref{sect:archoverview.net.documentserverlogic}.

\begin{figure}[H]
 \centering
 \includegraphics[width=15.70cm,height=5.72cm]{../images/finalreport/architecture_flows/publish.eps}
 \caption{Publishing a document}
 \label{fig:archoverview.flow.publish}
\end{figure}


\subsection{Discovery of Documents}
\label{sect:archoverview.flow.discovery}
A document published by one user is discovered by the other users. These
clients get notified about discovered documents through the method calls
depicted in the figure \ref{archoverview.flow.discovery}.

\begin{figure}[H]
 \centering
 \includegraphics[width=11.84cm,height=5.50cm]{../images/finalreport/architecture_flows/discovery.eps}
 \caption{Discovery of published documents}
 \label{fig:archoverview.flow.discovery}
\end{figure}

The network layer passes discovery events to the 
\texttt{NetworkServiceCallback}. That callback object is then responsible
to notify all registered \texttt{DocumentListener}s. The callback receives
objects of type \texttt{RemoteDocumentProxy}. It passes objects of type
\texttt{RemoteDocument} to the \texttt{DocumentListener}s. The reason
for that separation into \texttt{RemoteDocument} and 
\texttt{RemoteDocumentProxy} stems from the join procedure, which is
discussed next.


\subsection{Joining}

\subsubsection{Initiate Join}
\label{sect:archoverview.flow.initiatejoin}
Once a user has hold of a \texttt{RemoteDocument} he can opt to join the
published document represented by that \texttt{RemoteDocument}. In figure
\ref{fig:archoverview.flow.joininitiate} the initiating of a join
is depicted.

\begin{figure}[H]
 \centering
 \includegraphics[width=7.80cm,height=5.72cm]{../images/finalreport/architecture_flows/join_initiate.eps}
 \caption{Initiate a join request on the joiners site}
 \label{fig:archoverview.flow.joininitiate}
\end{figure}

The \texttt{join} method on the \texttt{RemoteDocument} takes an object of
type \texttt{JoinCallback}. This callback is used later to notify the
user that tries to join about the outcome of the join request (accepted or
rejected). The \texttt{join} method on the \texttt{RemoteDocument} has
a single parameter of type \texttt{JoinNetworkCallback}. The separation
into two different callback interfaces is caused by the fact that the
collaboration layer needs to add some processing when the join callback
is invoked.

\subsubsection{Receive Join Request}
The publisher is notified about a user that wants to join. This happens
through the method calls depicted in figure 
\ref{fig:archoverview.flow.joinrequest}.

\begin{figure}[H]
 \centering
 \includegraphics[width=7.83cm,height=5.50cm]{../images/finalreport/architecture_flows/join_request.eps}
 \caption{Publisher receives a JoinRequest}
 \label{fig:archoverview.flow.joinrequest}
\end{figure}

When the request is received from the network layer, the method
\texttt{join} is called on the \texttt{DocumentServerLogic} corresponding
to the document the user wants to join. The parameter of type 
\texttt{ParticipantConnection} is used later to communicate with the user
once the join request has been accepted. A user that is part of the session
is called a participant.

The collaboration layer then invokes the \texttt{joinRequest} method on
the \texttt{PublishedSessionCallback}. The publisher can then either accept or 
reject the request. In the following section, we have a look at the
situation where the publisher accepts the request (the other situation is
even simpler and should be understandable with the JavaDoc).

\subsubsection{Accepting Join Request}
The \texttt{JoinRequest} object is passed to the \texttt{joinRequest} method
of the \texttt{PublishedSessionCallback}. In our case, the publisher decides
to accept the join request. This happens by calling \texttt{accept} on the
\texttt{JoinRequest} object.

\begin{figure}[H]
 \centering
 \includegraphics[width=7.80cm,height=5.72cm]{../images/finalreport/architecture_flows/join_request_accept.eps}
 \caption{Publisher accepts the join request}
 \label{fig:archoverview.flow.joinrequestaccept}
\end{figure}

The collaboration layer then invokes the following methods in succession:
\begin{enumerate}
 \item \texttt{setParticipantId} - assigns the participant id
 \item \texttt{joinAccepted} - passes the \texttt{ParticipantPort} to the connection
 \item \texttt{sendDocument} - sends the initial document
\end{enumerate}

The \texttt{ParticipantPort} is used later by the network service to
pass requests from that particular participant (the one that just joined)
to the collaboration layer.

\subsubsection{Join Callback}
\label{sect:archoverview.flow.joinresponse}
The message that the join has been accepted is sent to the joining user. There,
the methods depicted in figure \ref{fig:archoverview.flow.joinresponse}
are called.

\begin{figure}[H]
 \centering
 \includegraphics[width=13.51cm,height=5.50cm]{../images/finalreport/architecture_flows/join_response.eps}
 \caption{Joining user receives session}
 \label{fig:archoverview.flow.joinresponse}
\end{figure}

In the section \ref{sect:archoverview.flow.initiatejoin} an object of type
\texttt{JoinCallback} has been passed to the collaboration layer, who in
turn has passed an object of type \texttt{JoinNetworkCallback} to the
network layer. These callback objects are now used to return the response
of the join.

First, the \texttt{accepted} method is called on the 
\texttt{JoinNetworkCallback} passing in a \texttt{SessionConnection}. The
\texttt{SessionConnection} is used by the collaboration layer to send messages 
to the session. The \texttt{accepted} method returns an object of type
\texttt{SessionConnectionCallback}, which is used by the network layer to
pass received messages from the session to the collaboration layer.

The collaboration layer gives the \texttt{accepted} message to the
\texttt{JoinCallback} passing along an object of type \texttt{Session}. That
object is used by the application layer to send messages to the session. The
\texttt{JoinCallback} returns a \texttt{ParticipantSessionCallback}, which
is used by the collaboration layer to pass received requests to the 
application layer.


\subsection{Communication in the Session}
The figure \ref{fig:archoverview.flow.session} shows how the messages flow
through the layers. The interface between the network and the collaboration
layer as depicted in the figure is only accurate for a participant. The
situation for a publisher is a bit different. The publisher gets a
session (more precisely a \texttt{PublishedSession}) through the
\texttt{publish} method of the \texttt{CollaborationService}. In ACE, both
the publisher and the server part of the session reside on the same
computer. Thus, there is no need for a \texttt{SessionConnection}. How the
connection between the publisher and the server part is achieved is completely
implementation specific and can thus not be described here.

\begin{figure}[H]
 \centering
 \includegraphics[width=11.78cm,height=6.00cm]{../images/finalreport/architecture_flows/session.eps}
 \caption{Communication in the Session}
 \label{fig:archoverview.flow.session}
\end{figure}


\subsection{Server-Side Communication with Participants}
In the last section we have shown how everything fits together for 
communicating in a Session. On the side of the publisher (or more specifically
on the host where the published document is hosted) the picture looks 
a bit different. The figure \ref{fig:archoverview.flow.portconnection}
shows the situation on the server.

\begin{figure}[H]
 \centering
 \includegraphics[width=9.56cm,height=4.09cm]{../images/finalreport/architecture_flows/portconnection.eps}
 \caption{Server-side Communication}
 \label{fig:archoverview.flow.portconnection}
\end{figure}

The \texttt{ParticipantConnection} is used by the server-side to communicate
with a particular participant. There is such a connection for each
participant in the session. In the other direction, that is from the
network layer to the collaboration layer, there is a 
\texttt{ParticipantPort} for each participant. The server logic is
responsible to forward messages from one participant (received over the
\texttt{ParticipantPort}) to all other participants (sending over the
\texttt{ParticipantConnection} objects). In between happens the transformation
of requests.


\subsection{Invitations}
In this section, we have a look at how invitations pass through the system.

\subsubsection{Sending an Invitation}
The publisher of a document can invite other users to an editing session.
The \texttt{PublishedSession} has a \texttt{invite} method, which serves
exactly that purpose.

\begin{figure}[H]
 \centering
 \includegraphics[width=7.34cm,height=5.72cm]{../images/finalreport/architecture_flows/invite_initiate.eps}
 \caption{Invite a user to a session}
 \label{fig:archoverview.flow.inviteinitiate}
\end{figure}

The collaboration layer passes the call to the \texttt{invite} method down
to the \texttt{DocumentServer}. The only parameter is of type 
\texttt{InvitationPort}, which serves as a callback to the collaboration layer
once the response to the invitation is received.

\subsubsection{Receiving Invitations}
The application layer can register an \texttt{InvitationCallback} with
the \texttt{CollaborationService} (\texttt{setInvitationCallback} method).
This callback object is notified about received invitations.

\begin{figure}[H]
 \centering
 \includegraphics[width=8.96cm,height=5.50cm]{../images/finalreport/architecture_flows/invite_receive.eps}
 \caption{Receiving an invitation}
 \label{fig:archoverview.flow.invitereceive}
\end{figure}

An invitation from another user is passed to the \texttt{invitationReceived}
method of the \texttt{NetworkServiceCallback} represented by a
\texttt{InvitationProxy} object. This invitation is passed to the
\texttt{InvitationCallback}. The \texttt{InvitationCallback} has a single method 
\texttt{invitation\-Received} with a parameter of type \texttt{Invitation}
The \texttt{Invitation} object provides methods to accept or reject
an invitation.

\subsubsection{Accepting an Invitation}
Once the application layer has received an \texttt{Invitation} object, the
invitation can be accepted (and rejected). We have a look now at the situation
where the invitation is accepted.

\begin{figure}[H]
 \centering
 \includegraphics[width=8.26cm,height=5.72cm]{../images/finalreport/architecture_flows/invite_accept.eps}
 \caption{Accepting an inviation}
 \label{fig:archoverview.flow.inviteaccept}
\end{figure}

The \texttt{accept} method takes a \texttt{JoinCallback} as parameter. The
collaboration layer calls \texttt{accept} on the \texttt{InvitationProxy}
in turn, passing in a \texttt{JoinNetworkCallback} instance. This is
exactly the same as a join request on a \texttt{RemoteDocument} (see
section \ref{{sect:archoverview.flow.initiatejoin}}). The session for the
document will be passed to the join callbacks (see section 
\ref{sect:archoverview.flow.joinresponse}).

\subsubsection{Invitation Response on the Server}
Once an invitation has been accepted or rejected by the invited user, a
message is sent back to the publisher. There, the \texttt{InvitationPort}
is used to report the server logic about the response.

\begin{figure}[H]
 \centering
 \includegraphics[width=8.26cm,height=3.70cm]{../images/finalreport/architecture_flows/invite_response.eps}
 \caption{Response to invitation on the server}
 \label{fig:archoverview.flow.inviteresponse}
\end{figure}

If the invitation is accepted by the invited user, the \texttt{InvitationPort}'s 
\texttt{accept} method is called passing in a \texttt{ParticipantConnection}.
This \texttt{accept} method is similar to the \texttt{join} method
of the \texttt{DocumentServerLogic}. The only difference is, that an
\texttt{accept} on an \texttt{InvitationPort} lets the invited user into
the session immediately (unless the session has been shutdown in the meantime).

The result of the invitation is not passed to the application layer. Future
versions of the API might introduce a way to notify the publisher about
accepted/rejected invitations.


\subsection{Explicit User Discovery}
Depending on the employed discovery mechanism by the network layer, the
automatic discovery works only on the local area network. To facilitate
collaboration with other users on the Internet, an explicit user discovery
mechanism exists. 

\subsubsection{Initiating Explicit User Discovery}
\begin{figure}[H]
 \centering
 \includegraphics[width=10.80cm,height=5.72cm]{../images/finalreport/architecture_flows/explicitdiscovery.eps}
 \caption{Initiating an explicit user discovery}
 \label{fig:archoverview.flow.explicitdiscovery}
\end{figure}

A \texttt{DiscoveryCallback} as well as an \texttt{InetAddress}/port pair 
is passed to the \texttt{CollaborationService}. This request is forwarded
to the \texttt{NetworkService}.

\subsubsection{Discovery Result}
The result of the explicit user discovery is passed through two different
channels. First, the result (success/failure) is passed to the
\texttt{DiscoveryCallback} (\texttt{DiscoveryNetworkCallback}
respectively).

\begin{figure}[H]
 \centering
 \includegraphics[width=15.63cm,height=5.50cm]{../images/finalreport/architecture_flows/explicitdiscovery_response.eps}
 \caption{The response of explicit user discovery}
 \label{fig:archoverview.flow.explicitdiscoveryresponse}
\end{figure}

If the discovery succeeds, the discovered user is passed through the
\texttt{UserListener}s to the application layer (see the section
\ref{sect:archoverview.flow.discovery}).
